\documentclass[a4paper]{article}
\input{head}
\begin{document}

% TITLE SECTION

\begin{figure}[h!]
\centering
\includegraphics[width=75mm]{logoDIREC.png}
\end{figure}

\fancyhead[C]{}
\hrule \medskip % Upper rule
\begin{minipage}{0.295\textwidth}
\raggedright
\footnotesize

Artur Barichello \hfill\\
Lucas Zacchi \hfill\\
Monique Bertan \hfill\\

\end{minipage}
\begin{minipage}{0.4\textwidth}
\centering
\large
Relatório 1\\
\normalsize
Sistemas Digitais\\
\end{minipage}
\begin{minipage}{0.295\textwidth}
\raggedleft
5 de abril de 2018\hfill\\
\end{minipage}
\medskip\hrule
\bigskip

% CONTENTS
%------------------------------------------------
\section{\textbf{Descrição do problema}}
%------------------------------------------------

Descrever uma ULA para números negativos e positivos de 16 bits com os seguintes componentes:
\begin{itemize}
\item Dois registradores.
\item Uma unidade para cálculo de complemento de 2.
\item Um seletor para utilizar ou pular o uso do complemento de dois e outro seletor anterior ao registrador A.
\item Um registrador de 1 bit para detecção de overflow.
\item Um somador com detecção de overflow.
\end{itemize}

%------------------------------------------------
\section{\textbf{Descrição da elaboração do trabalho}}
%-------------------------

O projeto foi feito com uma arquitetura topo abrigando 6 componentes, 7 instanciações destes componentes e 8 sinais internos entre os blocos.
Componentes como registradores foram feitos da maneira genérica enquanto os seletores foram feitos do modo estrutural.
\bigskip

\textbf{Mux estrutural}

Utilizamos um multiplexador 2:1 simples, com entradas e saídas de 16 bits, e uma entrada de seletor.

\begin{lstlisting}[language=VHDL]
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY mux2x1 IS
GENERIC (n: INTEGER := 16);
PORT (sel  : IN STD_LOGIC;
      w, x : IN SIGNED(n-1 DOWNTO 0);
	  m    : OUT SIGNED(n-1 DOWNTO 0));
END mux2x1;

ARCHITECTURE bhv OF mux2x1 IS
BEGIN
    m <= w WHEN sel = '0' ELSE x;
end bhv;
\end{lstlisting}
\bigskip

Utilizamos dois registradores distintos. O registrador A é um registrador genérico, enquanto o registrador B possui duas saídas de dados, uma que segue para o componente que realiza complemento de dois enquanto outra saída pula este componente.
\bigskip

\textbf{Registrador A genéricos de 16 bits:}
\begin{lstlisting}[language=VHDL]
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY register_a IS
GENERIC (n: INTEGER := 16);
PORT (clk : IN STD_LOGIC;
      d   : IN SIGNED(n-1 DOWNTO 0);
      q   : OUT SIGNED(n-1 DOWNTO 0));
END register_a;

ARCHITECTURE bhv OF register_a IS
BEGIN
    PROCESS(clk)
    BEGIN
        IF (RISING_EDGE(clk)) THEN
			q <= d;
        END IF;
    END PROCESS;
END bhv;
\end{lstlisting}

\pagebreak
\textbf{Registrador B com saída para o seletor (números positivos)}
\begin{lstlisting}[language=VHDL]
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY register_b IS
GENERIC (n: INTEGER := 16);
PORT (clk     : IN STD_LOGIC;
      d       : IN SIGNED(n-1 DOWNTO 0);
      q       : OUT SIGNED(n-1 DOWNTO 0);
		sel_out : OUT SIGNED(n-1 DOWNTO 0));
END register_b;

ARCHITECTURE bhv OF register_b IS
BEGIN
    PROCESS(clk)
    BEGIN
        IF (RISING_EDGE(clk)) THEN
				q <= d;
        END IF;
    END PROCESS;
END bhv;
\end{lstlisting}
\smallskip

O módulo do complemento de dois utiliza o operator NOT disponível em VHDL que inverte todos os bits da entrada e é associada a um sinal temporário, que Este sinal é incrementado em um e depois atribuido à saída. Assim, realizamos a operação de complemento de 2: Inverter os bits e somar 1 ao resultado.
\bigskip

\textbf{Módulo complemento de dois}
\begin{lstlisting}[language=VHDL]
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY comp2 IS
GENERIC (n: INTEGER := 16);
PORT (a_in  : IN SIGNED(n-1 DOWNTO 0);
		s_out : OUT SIGNED(N-1 DOWNTO 0));
END comp2;

ARCHITECTURE bhv OF comp2 IS
SIGNAL tmp : SIGNED(n-1 DOWNTO 0);

BEGIN
    tmp <= NOT a_in;
	 s_out <= SIGNED(tmp + 1);
end bhv;
\end{lstlisting}
\smallskip

O Somador completo de 16 bits com detecção de overflow foi projetado da seguinte maneira:
Ele possui entradas a e b com 16 bits, uma saída de overflow e uma com o resultado da soma. São criados 5 sinais internos temporários. Os sinais locala e localb recebem as entradas a e b com a função RESIZE, para passarem a ter 17 bits. O décimo sétimo bit é importante poruqe é onde será detectado o overflow. O sinal sum recebe a soma de locala e localb. Testamos o overflow com o sinal localflow, verificando se o último bit da soma (15) da soma é diferente do bit de sinal (16). Se sim, localflow recebe o valor '1'. E finalmente, os sinais são atribuiídos às saídas correspondentes.
\bigskip

\textbf{Somador com detecção de overflow}
\begin{lstlisting}[language=VHDL]
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_signed.all;

ENTITY adder IS
PORT (a, b     : IN  SIGNED(15 DOWNTO 0);
      overflow : OUT STD_LOGIC;
	  s        : OUT SIGNED(15 DOWNTO 0));
END adder;

ARCHITECTURE bhv OF adder IS
SIGNAL locala, localb, sum: SIGNED(16 DOWNTO 0); -- One bit more than input
SIGNAL localflow: STD_LOGIC;
SIGNAL sumout: SIGNED(16 DOWNTO 0);

BEGIN
	locala <= RESIZE((a), 17);
	localb <= RESIZE((b), 17);
	sum <= locala + localb;
	localflow <= '1' when sum(15) /= sum(16);
	sumout <= SIGNED(sum);
	overflow <= localflow;
	s <= sumout(16)&sum(14 DOWNTO 0);
END bhv;
\end{lstlisting}
\smallskip

\bigskip
\pagebreak
%------------------------------------------------
\section{\textbf{Testes e Simulações}}
%------------------------------------------------

\textbf{Estímulo adder}
\begin{lstlisting}[language=VHDL]
force /a 0000000000000000 0 ns, 0000000000000001 50 ns, 0000000000000010 100 ns, 0000000000000011 150 ns
force /b 0000000000000000 0 ns, 0000000000000000 50 ns, 0000000000000001 100 ns, 0000000000000010 150 ns
\end{lstlisting}
\smallskip

\textbf{Estímulo complemento de dois}
\begin{lstlisting}[language=VHDL]
force /a_in 0000000000000000 0 ns, 0000000000000001 50 ns, 0000000000000010 100 ns, 0000000000000011 150 ns
\end{lstlisting}
\smallskip

\textbf{Estímulo mux}
\begin{lstlisting}[language=VHDL]
force /sel 0 0 ns, 1 50 ns, -r 100  ns
force /w 0000000000000000 0 ns, 0000000000000001 50 ns, 0000000000000010 100 ns, 0000000000000011 150 ns
force /x 0000000000000001 0 ns, 0000000000000010 50 ns, 0000000000000011 100 ns, 0000000000000010 150 ns
\end{lstlisting}
\smallskip

\textbf{Estímulo registrador a}
\begin{lstlisting}[language=VHDL]
force /clk 0 0 ns, 1 50 ns, -r 100 ns
foce /d 0000000000000000 0 ns, 0000000000000001 50 ns, 0000000000000010 100 ns, 0000000000000011 150 ns
\end{lstlisting}
\smallskip

%------------------------------------------------
\section{\textbf{Resultados de atrasos e utilização da placa de cada módulo geral}}
%------------------------------------------------

\begin{figure}[H]
\centering
\includegraphics[width=190mm]{rega.png}
\caption{Temporização registrador A \label{Figura 1}}
\end{figure}
\smallskip

\begin{figure}[H]
\centering
\includegraphics[width=190mm]{regb.png}
\caption{Temporização registrador b \label{Figura 2}}
\end{figure}
\smallskip

\begin{figure}[H]
\centering
\includegraphics[width=190mm]{regover.png}
\caption{Temporização registrador 1 bit overflow \label{Figura 3}}
\end{figure}
\smallskip

\begin{figure}[H]
\centering
\includegraphics[width=190mm]{adder.png}
\caption{Temporização somador \label{Figura 4}}
\end{figure}
\smallskip

\begin{figure}[H]
\centering
\includegraphics[width=190mm]{comp2.png}
\caption{Temporização complemento de dois \label{Figura 5}}
\end{figure}
\smallskip

\begin{figure}[H]
\centering
\includegraphics[width=170mm]{ula.png}
\caption{Temporização ULA completa \label{Figura 6}}
\end{figure}
\smallskip

%------------------------------------------------
\section{\textbf{Arquivos VHDL e Estímulos}}
%------------------------------------------------

Os arquivos VHDL do projeto estão disponíveis na seção 2 onde os componentes são explicados um a um.

% END
\bigskip

\end{document}
